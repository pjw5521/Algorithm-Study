# 문제 풀이

## **신기한 소수**

### 문제링크
-  https://www.acmicpc.net/problem/2023

### 풀이 방법 
- 소수 규칙
    - 맨 앞자리가 2,3,5,7 이어야 함 
- dfs와 에라토스테네스의 채 사용해서 풀이 

</br>

## **두 동전**

### 문제링크
- https://www.acmicpc.net/problem/1005

### 풀이 방법 
- 처음 풀이 방법
    - bfs 로 풀이
    - 동전 두 개의 각 방문 표시 배열을 만들어서 체크해주면서 풀었는데 42%에서 자꾸 틀렸다는 결과
- 방문 표시가 아니라 범위를 벗어나면 continue로 처리해주니 해결되었다. 

</br>

## **ACM Craft**

### 문제 링크
- https://www.acmicpc.net/problem/1005

### 풀이 방법
- 위상 정렬과 dp 사용해서 풀이 
    - 오랜만에 위상 정렬 
- data[] : 인덱스 별 건설하는데 걸리는 시간으로 초기화하고 건설까지 소요되는 최소 시간 저장
- indegree[] : 인덱스 별 진입 차수 저장 
- graph[] : 건물 짓는 순서 규칙 저장 
- max_t[] : 해당 건물로 들어오는 바로 이전 건물들의 최대 건설 소요 시간

</br>

## **Strahler 순서**

### 문제 링크
- https://www.acmicpc.net/problem/9470

### 풀이 방법
- 위상 정렬 응용 
1. 진입차수와 연결 규칙 저장
2. 위상 정렬 수행 
    - num[] : 노드 번호 별 [들어오는 최대 레벨, 최대 레벨의 개수]
    - 진입 차수 0인 것 큐에 담고, num[i]의 최대 레벨 1, 레벨 1인 노드의 개수 1개 설정 
    - order[] : 순서 번호 저장할 배열 
    - while문 수행 
        - 큐에서 하나 씩 빼면서 최대 레벨의 개수가 1개 이상이면 
        ```python
        order[now] = num[now][0] + 1
        ```
        - 아니면 최대 레벨과 동일 
        ```python
        order[now] = num[now][0]
        ```
        - 해당 노드와 연결된 노드들의 진입 차수 -1 
        - 최대 레벨 번호와 같으면 개수 증가, 더크면 갱신 
        - 진입 차수 0이면 큐에 삽입 반복 
        
</br>

## **사회망 서비스(SNS)**

### 문제 링크
- https://www.acmicpc.net/problem/2533

### 풀이 방법
- 트리 dp 문제
- 핵심은 **얼리아답터가 아닌 사람의 모든 이웃 노드는 모두 얼리어답터야 한다는 것**
- 얼리어답터면 자식은 얼리어답처 여부가 상관없기 때문에 더 작은 경우 dp에 갱신 
- dp[i][0] : i번 노드가 얼리아답터 일 때 최소 수
- dp[i][1] : i번 노드가 얼리아답터가 아닐 때 최소 수
 - n이 얼리아답터이면 자식 노드가 얼리아답터 여부 관계없으므로 작은 값 가져오기 
    ```python
    dp[n][0] += min(dp[i][0], dp[i][1])
    ```
- n이 얼리아답터가 아니면 자식은 무조건 얼리아답터여야 함 
    ```python
    dp[n][1] += dp[i][0]
    ```
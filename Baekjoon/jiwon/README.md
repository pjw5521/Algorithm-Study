# 문제 풀이

## **신기한 소수**

### 문제링크
-  https://www.acmicpc.net/problem/2023

### 풀이 방법 
- 소수 규칙
    - 맨 앞자리가 2,3,5,7 이어야 함 
- dfs와 에라토스테네스의 채 사용해서 풀이 

</br>

## **두 동전**

### 문제링크
- ttps://www.acmicpc.net/problem/16197

### 풀이 방법 
- 처음 풀이 방법
    - bfs 로 풀이
    - 동전 두 개의 각 방문 표시 배열을 만들어서 체크해주면서 풀었는데 42%에서 자꾸 틀렸다는 결과
- 방문 표시가 아니라 범위를 벗어나면 continue로 처리해주니 해결되었다. 

</br>

## **ACM Craft**

### 문제 링크
- https://www.acmicpc.net/problem/1005

### 풀이 방법
- 위상 정렬과 dp 사용해서 풀이 
    - 오랜만에 위상 정렬 
- data[] : 인덱스 별 건설하는데 걸리는 시간으로 초기화하고 건설까지 소요되는 최소 시간 저장
- indegree[] : 인덱스 별 진입 차수 저장 
- graph[] : 건물 짓는 순서 규칙 저장 
- max_t[] : 해당 건물로 들어오는 바로 이전 건물들의 최대 건설 소요 시간

</br>

## **Strahler 순서**

### 문제 링크
- https://www.acmicpc.net/problem/9470

### 풀이 방법
- 위상 정렬 응용 
1. 진입차수와 연결 규칙 저장
2. 위상 정렬 수행 
    - num[] : 노드 번호 별 [들어오는 최대 레벨, 최대 레벨의 개수]
    - 진입 차수 0인 것 큐에 담고, num[i]의 최대 레벨 1, 레벨 1인 노드의 개수 1개 설정 
    - order[] : 순서 번호 저장할 배열 
    - while문 수행 
        - 큐에서 하나 씩 빼면서 최대 레벨의 개수가 1개 이상이면 
        ```python
        order[now] = num[now][0] + 1
        ```
        - 아니면 최대 레벨과 동일 
        ```python
        order[now] = num[now][0]
        ```
        - 해당 노드와 연결된 노드들의 진입 차수 -1 
        - 최대 레벨 번호와 같으면 개수 증가, 더크면 갱신 
        - 진입 차수 0이면 큐에 삽입 반복 
        
</br>

## **사회망 서비스(SNS)**

### 문제 링크
- https://www.acmicpc.net/problem/2533

### 풀이 방법
- 트리 dp 문제
- 핵심은 **얼리아답터가 아닌 사람의 모든 이웃 노드는 모두 얼리어답터야 한다는 것**
- 얼리어답터면 자식은 얼리어답처 여부가 상관없기 때문에 더 작은 경우 dp에 갱신 
- dp[i][0] : i번 노드가 얼리아답터 일 때 최소 수
- dp[i][1] : i번 노드가 얼리아답터가 아닐 때 최소 수
 - n이 얼리아답터이면 자식 노드가 얼리아답터 여부 관계없으므로 작은 값 가져오기 
    ```python
    dp[n][0] += min(dp[i][0], dp[i][1])
    ```
- n이 얼리아답터가 아니면 자식은 무조건 얼리아답터여야 함 
    ```python
    dp[n][1] += dp[i][0]
    ```
    
</br>


## **A->B**

### 문제 링크
- https://www.acmicpc.net/problem/16953


### 풀이 방법
- 간단한 bfs 문제 
- 큐에 2를 곱한 값과 오른쪽에 1을 추가한 값을 넣어주면서 b가 나오면 연산 횟수 리턴 

<br>


## **숨바꼭질4**

### 문제 링크
- https://www.acmicpc.net/problem/13913

### 풀이 방법 
1. 첫번째 풀이 방식 
- 큐에 route라는 배열도 함께 넣어줘서 위치를 이동할 때마다 route 배열에 경로를 추가해주어 원하는 위치에 도착하면 route 배열에 담긴 경로를 출력하는 방식으로 구현 
    - 내가 구현한 것처럼 경로를 모두 다 기록하게 되면 결과적으로 O(n^2)의 메모리가 필요하게 되어 메모리 초과 발생 
    - 따라서 모든 경로를 저장하는 것이 아니라, 자취를 남기는 식으로 구현해야 함
    
2. 두번째 풀이 방식
- path 배열에 자취 저장 
- path[a]= b : b에서 a 로 왔음 
- k에 도착했을 때 path 배열을 거꾸로 읽어가면 경로를 알 수 있음 

<br>


## **이모티콘**

### 문제 링크
- https://www.acmicpc.net/problem/14226

<br>

### 풀이 방법 
- bfs 풀이
- 큐에  ( 화면에 있는 이모티콘 개수, 클립모드에 있는 이모티콘 개수, 연산 횟수)를 넣어주고 bfs 를 실행
- visited[화면개수][클립보드개수]로 방문 표시
- 화면에 있는 이모티콘 개수가 s와 같으면 연산 횟수 return 
1. 클립보드에 저장할 경우 방문하지 않았으면 
큐에 (화면개수, 화면개수, 연산횟수 +1)을 넣어주고 방문 표시 
2. 화면에 붙여넣기 할 경우 방문하지 않았으면 
큐에 (화면개수 + 클립보드개수, 클립보드개수, 연산횟수 +1) 을 넣어주고 방문 표시 
3. 하나 삭제할 경우 방문하지 않았으면 
큐에 (화면개수-1, 클립보드개수, 연산횟수 +1)을 넣어주고 방문 표시하면 된다. 
- 원래 처음에는 배열 크기를 1001 만큼 선언해주었는데, 런타임 에러가 발생 
    - 크기를 s+1로 변경해주니 해결되었는데 왜 ? 

<BR>

## **아기상어2**

### 문제 링크
- https://www.acmicpc.net/problem/17086

### 풀이 과정 
- bfs 풀이
- 아기 상어가 아닌 위치마다 bfs로 가장 가까운 아기 상어까지 거리를 구한 후 최댓값을 갱신

<br/>

## **테트로미노**

### 문제 링크
- https://www.acmicpc.net/problem/14500

### 풀이 과정 
- 문제의 핵심은 **'ㅜ' 모양을 제외한 다른 모든 테트로미노는 정사각형을 4번 연결하여 만들어진 모양**이다. 따라서 dfs 를 4번 실행하여 모양에 해당하는 최댓값을 찾으면 된다. 
- 'ㅜ'모양은 정사각형 두 개를 연결한 다음 해당 위치에서 다음 정사각형으로 이동하지 않고 다음 위치는 방문 표시 하되, 현재 위치에서 탐색하면 된다. 
- 시간 복잡도를 줄이기 위해 graph에 최댓값을 저장해두고 만약 지금까지 칸 수의 합이 남은 칸수가 모두 최댓값이라고 했을 때의 합보다 크다면 return 
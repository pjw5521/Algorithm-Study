# 백준 2주차 <br/><br/>

## Problem1

문제: A -> B (https://www.acmicpc.net/problem/16953)

### Solution

Step 1. b 라는 숫자를 회귀 하면서 진행했다.

Step 2. b라는 숫자의 맨 마지막 자리가 1 이거나 혹은 2로 나누어지는 경우를 반복한다. 
- 맨 뒷자리에 1을 더하는것 => 회귀 방식이면 맨 뒤에 1의 자리를 빼는것이 cnt를 최소화 시킨다 (greedy)

Step 3. a 가 b 보다 커지는 경우 혹은 2로 나누어지지 않거나 뒤에 1이 없는 경우 될 수 없는 숫자이므로 -1을 return 한다.


<br/>

## Problem2

문제: 이모티콘 (https://www.acmicpc.net/problem/14226)

### Solution

Step 1. 처음 문제를 이해했을때 복사 - 붙여넣기 - 복사 - 붙여넣기를 해야 하는 것으로 이해했지만 클립보드에 들어있는 이모티콘은 여러 번 화면에 붙여넣기가 가능하다.  

Step 2. bfs를 통해 주어진 모든 경우의 수를 구하면서 이전에 구했던 경우는 피해야한다(런타임 에러). -> 그래서 중복 계산을 방지한다.(방문 표시와 같은 역활)

Step 3. 화면의 이모티콘 갯수: screen 과 클립보드에 이모티콘 갯수: clip을 고려하면서 푼다
- 화면에 있는 이모티콘을 클립보드에 저장한다: (화면에 표시된 이모티콘 , 클립보드 내 이모티콘(처음엔 0)) -> (화면에 표시된 이모티콘,화면에 표시된 이모티콘)
- 클립보드에 있는 모든 이모티콘을 화면에 붙여넣는다: (화면에 표시된 이모키콘,클립보드 내 이모티콘) -> (화면 이모티콘 + 클립 이모티콘, 클립 이모티콘)
- 화면에 있는 이모티콘 중 하나를 삭제한다: (화면에 표시된 이모티콘, 클립 이모티콘) -> (화면 이모티콘-1, 클립 이모티콘)

## Problem3

문제: 아기상어2 (https://www.acmicpc.net/problem/17086)

### Solution

Step 1. bfs를 이용하여 풀었다.

Step 2. 상어의 위치를 이용하여 상어의 위치부터 시작하여 bfs를 진행했다.
- 주어진 그래프 내 아기상어 위치를 큐에 삽입
- 해당 좌표부터 상하좌우, 대각 모든 방향으로 1칸씩 이동하여 +1 해준다.
- 만약 그래프를 벗어나면 다음 q에서 pop을 하여 진행
- 그래프를 벗어나지 않았다면 상어인지 판별
- 상어가 아니라면 새로운 좌표의 거리값은 출발지점에서 +1 해서 할당 이후 큐에 삽입
- 그래프 내 원소 중 최대값 출력

<img width="208" alt="스크린샷 2022-06-18 오후 6 54 22" src="https://user-images.githubusercontent.com/60414900/174432583-756cd6c8-d5ba-4ad1-95e6-d2355164039a.png">

<br/>

## Problem4

문제: 숨박꼭질4 (https://www.acmicpc.net/problem/13913)

### Solution

Step 1. 이전에 풀었던 a->b 와 비슷하게 접근했지만 -1 이라는 활동범위가 가능해지기 때문에 도착해야하는 값보다 커졌을 때도 가능하기 때문에 실패

Step 2. 그림 참고

<img width="327" alt="스크린샷 2022-06-19 오후 2 25 20" src="https://user-images.githubusercontent.com/60414900/174467188-617013f8-4e90-4e2d-b3f1-bc1c529d5b23.png">





